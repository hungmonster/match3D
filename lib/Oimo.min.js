async function OimoPhysics() { function e(e) { const n = e.parameters; if ("BoxGeometry" === e.type) { const e = void 0 !== n.width ? n.width / 2 : .5, t = void 0 !== n.height ? n.height / 2 : .5, o = void 0 !== n.depth ? n.depth / 2 : .5; return new OIMO.OBoxGeometry(new OIMO.Vec3(e, t, o)) } if ("SphereGeometry" === e.type || "IcosahedronGeometry" === e.type) { const e = void 0 !== n.radius ? n.radius : 1; return new OIMO.OSphereGeometry(e) } return null } function n(n, i = 0) { const s = e(n.geometry); null !== s && (n.isInstancedMesh ? o(n, i, s) : n.isMesh && t(n, i, s)) } function t(e, n, t) { const o = new OIMO.ShapeConfig; o.geometry = t; const i = new OIMO.RigidBodyConfig; i.type = 0 === n ? OIMO.RigidBodyType.STATIC : OIMO.RigidBodyType.DYNAMIC, i.position = new OIMO.Vec3(e.position.x, e.position.y, e.position.z); const s = new OIMO.RigidBody(i); s.addShape(new OIMO.Shape(o)), O.addRigidBody(s), n > 0 && (d.push(e), r.set(e, s)) } function o(e, n, t) { const o = e.instanceMatrix.array, i = []; for (let s = 0; s < e.count; s++) { const e = 16 * s, c = new OIMO.ShapeConfig; c.geometry = t; const d = new OIMO.RigidBodyConfig; d.type = 0 === n ? OIMO.RigidBodyType.STATIC : OIMO.RigidBodyType.DYNAMIC, d.position = new OIMO.Vec3(o[e + 12], o[e + 13], o[e + 14]); const r = new OIMO.RigidBody(d); r.addShape(new OIMO.Shape(c)), O.addRigidBody(r), i.push(r) } n > 0 && (d.push(e), r.set(e, i)) } function i(e, n, t = 0) { if (e.isInstancedMesh) { const o = r.get(e), i = o[t]; i.setPosition(new OIMO.Vec3(n.x, n.y, n.z)) } else if (e.isMesh) { const t = r.get(e); t.setPosition(new OIMO.Vec3(n.x, n.y, n.z)) } } function s() { const e = performance.now(); y > 0 && O.step(1 / c), y = e; for (let e = 0, n = d.length; e < n; e++) { const n = d[e]; if (n.isInstancedMesh) { const e = n.instanceMatrix.array, t = r.get(n); for (let n = 0; n < t.length; n++) { const o = t[n]; compose(o.getPosition(), o.getOrientation(), e, 16 * n) } n.instanceMatrix.needsUpdate = !0 } else if (n.isMesh) { const e = r.get(n); n.position.copy(e.getPosition()), n.quaternion.copy(e.getOrientation()) } } } const c = 60, O = new OIMO.World(2, new OIMO.Vec3(0, -9.8, 0)), d = [], r = new WeakMap; let y = 0; return setInterval(s, 1e3 / c), { addMesh: n, setMeshPosition: i } } function compose(e, n, t, o) { const i = n.x, s = n.y, c = n.z, O = n.w, d = i + i, r = s + s, y = c + c, a = i * d, p = i * r, M = i * y, h = s * r, I = s * y, g = c * y, f = O * d, w = O * r, u = O * y; t[o + 0] = 1 - (h + g), t[o + 1] = p + u, t[o + 2] = M - w, t[o + 3] = 0, t[o + 4] = p - u, t[o + 5] = 1 - (a + g), t[o + 6] = I + f, t[o + 7] = 0, t[o + 8] = M + w, t[o + 9] = I - f, t[o + 10] = 1 - (a + h), t[o + 11] = 0, t[o + 12] = e.x, t[o + 13] = e.y, t[o + 14] = e.z, t[o + 15] = 1 } import *as OIMO from "./OimoIndex.js"; export { OimoPhysics };